use crate::Vector;

#[derive(Debug)]
/// A `Lattice` is generated by an nxm basis
pub struct Lattice<T> {
    pub basis: Vec<Vector<T>>,
}

impl<T> Lattice<T>
where
    T: std::ops::Mul<T, Output = T> + std::ops::Add<T, Output = T> + std::default::Default + Copy,
{
    /// Initialize a `Lattice`
    pub fn init(b: &Vec<Vec<T>>) -> Self {
        Self {
            basis: b.iter().map(|i| Vector::init(i)).collect(),
        }
    }

    /// Compute the Gram-Schmidt orthogonalization of B
    pub fn gso(&self) -> Vec<Vector<f64>>
    where
        f64: From<T>,
    {
        let n = self.basis.len();
        let m = self.basis[0].vec.len();

        let mut mu = vec![vec![0f64; m]; n];
        let mut gs: Vec<Vector<f64>> = self.basis.iter().map(|i| i.to_f64()).collect();

        for i in 0..self.basis.len() {
            for j in 0..i {
                mu[i][j] = gs[i].iprod(&self.basis[j]) / gs[j].norm;
                for k in 0..self.basis.len() {
                    gs[i].vec[k] -= mu[i][j] * gs[j].vec[k];
                }
            }
            gs[i].norm = gs[i].iprod(&gs[i]);
        }

        gs
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gs() {
        let b = vec![vec![1, 1, 0], vec![1, 2, 0], vec![0, 1, 2]];
        let l = Lattice::init(&b);
        let gs = l.gso();
        dbg!(gs);

        let b = vec![vec![1, -1, 1], vec![1, 0, 1], vec![1, 1, 2]];
        let l = Lattice::init(&b);
        let gs = l.gso();
        dbg!(gs);
    }
}
